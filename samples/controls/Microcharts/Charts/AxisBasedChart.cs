// Copyright (c) Alo√Øs DENIEL. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.StandardUI;
using Microsoft.StandardUI.Controls;
using SkiaSharp;

namespace Microcharts
{
    /// <summary>
    /// Base chart for Series chart based on Axis work
    /// </summary>
    public abstract class AxisBasedChart : SeriesChart
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="T:Microcharts.AxisBasedChart"/> class.
        /// </summary>
        public AxisBasedChart(IChart control) : base(control)
        {
            LabelOrientation = Orientation.Default;
            ValueLabelOrientation = Orientation.Default;

            YAxisTextPaint = new SKPaint
            {
                Color = SKColors.Black,
                IsAntialias = true,
                Style = SKPaintStyle.StrokeAndFill,
            };

            YAxisLinesPaint = new SKPaint
            {
                Color = Colors.Black.WithA(0x50),
                IsAntialias = true,
                Style = SKPaintStyle.Stroke
            };
        }

        /// <inheritdoc />
        protected override void GenerateDefaultSeries(IEnumerable<ChartEntry> value)
        {
            //To maintain a continuity with the previous barchart version,
            //we set properties accordingly to match the previous behaviors
            //OnLabelOrientationChanged();
            OnLabelTextSizeChanged();

            base.GenerateDefaultSeries(value);
        }

        /// <inheritdoc />
        protected override void OnLabelTextSizeChanged()
        {
            if (IsSeriesAutoGenerated && valueLabelTextSizeDefaultValue)
                ValueLabelTextSize = LabelTextSize;
        }

        /// <summary>
        /// Draws the content of the chart onto the specified canvas.
        /// </summary>
        /// <param name="canvas">The output canvas.</param>
        /// <param name="width">The width of the chart.</param>
        /// <param name="height">The height of the chart.</param>
        public override void DrawContent(ICanvas canvas, int width, int height)
        {
            if (Control.Series != null && Control.Entries != null)
            {
                //Caching the min/max values for performance
                bool fixedRange = InternalMaxValue.HasValue || InternalMinValue.HasValue;

                //Ideally we'd use the internal values here, but the drawing does not crop to the bounds
                //So the min and min cannot be set less than the actual min/max of the values
                float maxValue = MaxValue;
                float minValue = MinValue;

                //This function might change the min/max value
                width = MeasureHelper.CalculateYAxis(Control.ShowYAxisText, Control.ShowYAxisLines, Control.Entries, Control.YAxisMaxTicks, Control.YAxisTextPaint, Control.YAxisPosition, width, fixedRange, ref maxValue, ref minValue, out float yAxisXShift, out List<float> yAxisIntervalLabels);
                float valRange = maxValue - minValue;

                var firstSerie = Series.FirstOrDefault();
                var labels = firstSerie.Entries.Select(x => x.Label).ToArray();
                int nbItems = labels.Length;

                var groupedEntries = Control.Entries.GroupBy(x => x.Label);

                int barPerItems = groupedEntries.Max(g => g.Count());

                var seriesNames = Series.Select(s => s.Name).ToArray();
                var seriesSizes = MeasureHelper.MeasureTexts(seriesNames, Control.SeriesLabelTextSize);
                float legendHeight = CalculateLegendSize(seriesSizes, Control.SeriesLabelTextSize, width);

                var labelSizes = MeasureHelper.MeasureTexts(labels, Control.LabelTextSize);
                var footerHeight = MeasureHelper.CalculateFooterHeaderHeight(Control.Margin, Control.LabelTextSize, labelSizes, Control.LabelOrientation);
                var footerWithLegendHeight = footerHeight + (Control.LegendOption == SeriesLegendOption.Bottom ? legendHeight : 0);

                var valueLabelSizes = MeasureValueLabels();
                float headerHeight = CalculateHeaderHeight(valueLabelSizes);
                var headerWithLegendHeight = headerHeight + (Control.LegendOption == SeriesLegendOption.Top ? legendHeight : 0);

                var itemSize = CalculateItemSize(nbItems, width, height, footerHeight + headerHeight + legendHeight);
                var barSize = CalculateBarSize(itemSize, Series.Count());
                var origin = CalculateYOrigin((float)itemSize.Height, headerWithLegendHeight, maxValue, minValue, valRange);
                DrawHelper.DrawYAxis(Control.ShowYAxisText, Control.ShowYAxisLines, Control.YAxisPosition, Control.YAxisTextPaint, Control.YAxisLinesPaint, Control.Margin, AnimationProgress, maxValue, valRange, canvas, width, yAxisXShift, yAxisIntervalLabels, headerHeight, itemSize, origin);

                int nbSeries = series.Count();
                for (int serieIndex = 0; serieIndex < nbSeries; serieIndex++)
                {
                    ChartSeries series = Series.ElementAt(serieIndex);
                    IEnumerable<ChartEntry> entries = series.Entries;
                    int entryCount = entries.Count();

                    for (int i = 0; i < labels.Length; i++)
                    {
                        var itemX = Control.Margin + (itemSize.Width / 2) + (i * (itemSize.Width + Control.Margin)) + yAxisXShift;

                        string label = labels[i];
                        if (!string.IsNullOrEmpty(label))
                        {
                            Rect labelSize = labelSizes[i];
                            DrawHelper.DrawLabel(canvas, Control.LabelOrientation, YPositionBehavior.None, itemSize, new Point(itemX, height - footerWithLegendHeight + Control.Margin), Control.LabelColor, labelSize, label, LabelTextSize, Typeface);
                        }
                    }


                    for (int i = 0; i < labels.Length; i++)
                    {
                        if (i >= entryCount) break;
                        var itemX = Control.Margin + (itemSize.Width / 2) + (i * (itemSize.Width + Control.Margin)) + yAxisXShift;

                        ChartEntry entry = entries.ElementAt(i);
                        if (entry != null && entry.Value.HasValue)
                        {
                            float value = entry.Value.Value;
                            float marge = serieIndex < nbSeries ? Control.Margin / 2 : 0;
                            float totalBarMarge = serieIndex * Control.Margin / 2;
                            double barX = itemX + serieIndex * barSize.Width + totalBarMarge;
                            double barY = headerWithLegendHeight + ((1 - AnimationProgress) * (origin - headerWithLegendHeight) + (((maxValue - value) / valRange) * itemSize.Height) * AnimationProgress);

                            DrawBarArea(canvas, headerWithLegendHeight, itemSize, barSize, series.Color ?? entry.Color, origin, value, barX, barY);
                            DrawBar(series, canvas, headerWithLegendHeight, itemX, itemSize, barSize, origin, barX, barY, series.Color ?? entry.Color);
                            DrawValueLabel(canvas, valueLabelSizes, headerWithLegendHeight, itemSize, barSize, entry, barX, barY, itemX, origin);
                        }
                        else
                        {
                            DrawNullPoint(series, canvas);
                        }
                    }
                }

                DrawLegend(canvas, seriesSizes, legendHeight, height, width);
                OnDrawContentEnd(canvas, itemSize, origin, valueLabelSizes);
            }
        }

        /// <summary>
        /// Calculate the header height to take care of the value label size display
        /// </summary>
        /// <param name="valueLabelSizes"></param>
        /// <returns>The calculated header height</returns>
        protected virtual float CalculateHeaderHeight(Dictionary<ChartEntry, Rect> valueLabelSizes)
        {
            return MeasureHelper.CalculateFooterHeaderHeight(Control.Margin, Control.ValueLabelTextSize, valueLabelSizes.Values.ToArray(), Control.ValueLabelOrientation);
        }

        /// <summary>
        /// Draw the value label of the corresponding entry on the canvas
        /// </summary>
        protected virtual void DrawValueLabel(ICanvas canvas, Dictionary<ChartEntry, Rect> valueLabelSizes, float headerWithLegendHeight, Size itemSize, Size barSize, ChartEntry entry, float barX, float barY, float itemX, float origin)
        {
            string label = entry?.ValueLabel;
            if (!string.IsNullOrEmpty(label))
                DrawHelper.DrawLabel(canvas, Control.ValueLabelOrientation, YPositionBehavior.UpToElementHeight, barSize, new Point(barX - (itemSize.Width / 2) + (barSize.Width / 2), headerWithLegendHeight - Control.Margin), entry.ValueLabelColor.WithA((byte)(255 * AnimationProgress)), valueLabelSizes[entry], label, Control.ValueLabelTextSize, Control.Typeface);
        }

        /// <summary>
        /// Method executed after the DrawContent parts
        /// </summary>
        /// <remarks>Usable by children to draw others contents on the canvas</remarks>
        /// <param name="canvas">canvas of the chart</param>
        /// <param name="itemSize">size of an item (per label)</param>
        /// <param name="origin">the calculated y origin</param>
        /// <param name="valueLabelSizes">Value label size by entry</param>
        protected virtual void OnDrawContentEnd(ICanvas canvas, Size itemSize, float origin, Dictionary<ChartEntry, Rect> valueLabelSizes)
        {
        }

        private void DrawLegend(ICanvas canvas, Rect[] seriesNameSize, float legendHeight, float height, float width)
        {
            if (Control.LegendOption == SeriesLegendOption.None)
                return;

            if (Series.Any(s => !s.Color.HasValue))
                throw new ArgumentNullException(nameof(ChartSeries.Color), "Unable to draw legend without set a color in ChartSerie");

            float lineHeight = Math.Max(seriesNameSize.Where(b => !b.IsEmpty).Select(b => b.Height).FirstOrDefault(), Control.SeriesLabelTextSize);

            float origin = Control.Margin;
            if (Control.LegendOption == SeriesLegendOption.Bottom)
                origin += height - legendHeight;

            int nbLine = 1;
            float currentWidthUsed = 0;
            var series = Series.ToArray();
            for (int i = 0; i < series.Length; i++)
            {
                var serie = series[i];
                var seriesBound = seriesNameSize[i];

                float legentItemWidth = (float) (Control.Margin + Control.SeriesLabelTextSize + Control.Margin + seriesBound.Width);
                if (legentItemWidth > width)
                {
                    if (currentWidthUsed != 0)
                    {
                        nbLine++;
                        currentWidthUsed = 0;
                    }

                    currentWidthUsed = GenerateSeriesLegend(canvas, lineHeight, origin, nbLine, currentWidthUsed, serie);
                }
                else if (legentItemWidth + currentWidthUsed > width)
                {
                    nbLine++;
                    currentWidthUsed = 0;
                    currentWidthUsed = GenerateSeriesLegend(canvas, lineHeight, origin, nbLine, currentWidthUsed, serie);
                }
                else
                {
                    currentWidthUsed = GenerateSeriesLegend(canvas, lineHeight, origin, nbLine, currentWidthUsed, serie);
                }
            }

        }

        private float GenerateSeriesLegend(ICanvas canvas, float lineHeight, float origin, int nbLine, float currentWidthUsed, ChartSeries series)
        {
            var legendColor = series.Color.Value.WithA((byte)(series.Color.Value.A * AnimationProgress));
            var lblColor = Control.LabelColor.WithA((byte)(Control.LabelColor.A * AnimationProgress));
            var yPosition = origin + (nbLine - 1) * (lineHeight + Control.Margin);
            var rect = SKRect.Create(currentWidthUsed + Control.Margin, yPosition, Control.SeriesLabelTextSize, Control.SeriesLabelTextSize);
            using (var paint = new SKPaint
            {
                Style = SKPaintStyle.Fill,
                Color = legendColor
            })
            {
                canvas.DrawRect(rect, paint);
            }

            currentWidthUsed += Control.Margin + Control.SeriesLabelTextSize + Control.Margin;
            using (var paint = new SKPaint())
            {
                paint.TextSize = Control.SeriesLabelTextSize;
                paint.IsAntialias = true;
                paint.Color = lblColor;
                paint.IsStroke = false;
                paint.Typeface = Control.Typeface;

                var bounds = new SKRect();
                paint.MeasureText(series.Name, ref bounds);
                //Vertical center align the text to the legend color box
                float textYPosition = rect.Bottom - ((rect.Bottom - rect.Top) / 2) + (bounds.Height / 2);
                canvas.DrawText(series.Name, currentWidthUsed, textYPosition, paint);
                currentWidthUsed += bounds.Width;
            }

            return currentWidthUsed;
        }

        private float CalculateLegendSize(Rect[] seriesSizes, float seriesLabelTextSize, int width)
        {
            if (Control.LegendOption == SeriesLegendOption.None)
                return 0;

            int nbLine = 1;
            double currentWidthUsed = 0;
            foreach(var rect in seriesSizes)
            {
                double legentItemWidth = Control.Margin + seriesLabelTextSize + Control.Margin + rect.Width;
                if (legentItemWidth > width)
                {
                    if (currentWidthUsed != 0)
                        nbLine++;
                    currentWidthUsed = width;
                }
                else if (legentItemWidth + currentWidthUsed > width)
                {
                    nbLine++;
                    currentWidthUsed = legentItemWidth;
                }
            }

            float height = Math.Max(seriesSizes.Where(b => !b.IsEmpty).Select(b => b.Height).FirstOrDefault(), seriesLabelTextSize);

            return nbLine * height + nbLine * Control.Margin;
        }

        private float CalculateYOrigin(float itemHeight, float headerHeight, float max, float min, float range)
        {
            if (max <= 0)
            {
                return headerHeight;
            }

            if (min > 0)
            {
                return headerHeight + itemHeight;
            }

            return headerHeight + ((max / range) * itemHeight);
        }

        private Dictionary<ChartEntry, Rect> MeasureValueLabels()
        {
            var dict = new Dictionary<ChartEntry, Rect>();
            using (var paint = new SKPaint())
            {
                paint.TextSize = Control.ValueLabelTextSize;
                foreach (var e in Control.Entries)
                {
                    Rect bounds;
                    if (string.IsNullOrEmpty(e.ValueLabel))
                    {
                        bounds = Rect.Empty;
                    }
                    else
                    {
                        bounds = new Rect();
                        paint.MeasureText(e.ValueLabel, ref bounds);
                    }

                    dict.Add(e, bounds);
                }
            }

            return dict;
        }

        /// <summary>
        /// Draw bar (or point) item of an entry
        /// </summary>
        protected abstract void DrawBar(ChartSeries serie, ICanvas canvas, float headerHeight, float itemX, Size itemSize, Size barSize, float origin, float barX, float barY, Color color);

        /// <summary>
        /// Called during the draw cycle when encountering a point with a null value
        /// </summary>
        protected virtual void DrawNullPoint(ChartSeries serie, ICanvas canvas) { }

        /// <summary>
        /// Draw bar (or point) area of an entry
        /// </summary>
        protected abstract void DrawBarArea(ICanvas canvas, float headerHeight, Size itemSize, Size barSize, Color color, float origin, float value, float barX, float barY);

        private Size CalculateBarSize(Size itemSize, int barPerItems)
        {
            var w = (itemSize.Width - ((barPerItems - 1) * Control.Margin / 2)) / barPerItems;
            return new Size(w, itemSize.Height);
        }

        private Size CalculateItemSize(int items, int width, int height, float reservedSpace)
        {
            var w = (width - ((items + 1) * Control.Margin)) / items;
            var h = height - Control.Margin - reservedSpace;
            return new Size(w, h);
        }
    }
}
